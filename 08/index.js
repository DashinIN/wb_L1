// 8.	Задача о замыканиях: напишите функцию, которая будет принимать массив функций и возвращать новую функцию, 
// которая вызывает каждую функцию в этом массиве и возвращает массив результатов.


function createClosure(arrayOfFunctions) {
  return function() {
    let results = [];

    for (let i = 0; i < arrayOfFunctions.length; i++) {
      results.push(arrayOfFunctions[i].apply(this, arguments));
    }

    return results;
  }
}

// Пример использования:
const functions = [
  function(a) { return a + 1; },
  function(b) { return b * 2; },
  function(c) { return c - 3; }
];

const closure = createClosure(functions);
const results = closure(5); // Результат: [6, 10, 2]

console.log(results)

// В этом решении функция createClosure принимает массив arrayOfFunctions
//  в качестве аргумента. Она возвращает новую функцию, которая использует
//   замыкание для доступа к arrayOfFunctions.

// Внутри новой функции мы создаем пустой массив results, в
//  который будем сохранять результаты вызова каждой функции из arrayOfFunctions.

// Затем мы проходим по массиву arrayOfFunctions с помощью цикла for. На 
// каждой итерации мы вызываем текущую функцию, используя метод apply() для 
// передачи аргументов из нашей новой функции. Результат вызова функции добавляем в массив results.

// По окончании цикла, мы возвращаем массив results, содержащий результаты
//  вызова каждой функции.

// В примере использования мы создаем массив функций functions. Затем мы
// вызываем createClosure с этим массивом и присваиваем возвращенную функцию
// переменной closure. Затем мы вызываем closure(5), передавая аргумент 5. 
// Результат будет массив [6, 10, 2], соответствующий результату вызова каждой функции с аргументом 5.